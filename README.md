# 4190.307 Operating Systems (Fall 2025)
# Project #2: Ping, Pong
### Due: 11:59 PM, October 12 (Sunday)

## Introduction

An Inter-Processor Interrupt (IPI) is a hardware-delivered signal from one CPU core to another, which is the kernel's primary low-latency mechanism for coordinating work on multicore systems. In this project, you will implement a minimal IPI mechanism in `xv6` that lets one RISC-V hart simply ring a "doorbell" on another. The goal is to deepen your understanding of `xv6` system calls and interrupt handling on the RISC-V architecture.

## Background

### RISC-V Trap Architecture

In RISC-V, a ___trap___ is a general term that encompasses both ___exceptions___ and ___interrupts___ (see Chap. 4 of the [xv6 book](http://csl.snu.ac.kr/courses/4190.307/2025-2/book-riscv-rev5.pdf)). Exceptions are typically generated by the CPU itself in response to events such as illegal instructions, memory access faults, system call invocations via the `ecall` instruction, etc. Interrupts, by contrast, are triggered by external signals from devices or timers that indicate they require immediate attention. 

RISC-V supports multiple privilege levels (machine, supervisor, and user modes), each with its own set of capabilities and restrictions. Traps can be configured to be handled at different privilege levels depending on their type and the processor's current operating mode. When a trap occurs, the RISC-V hart automatically fills a register (`mcause` or `scause` depending on the privilege level) with a value that indicates the reason for the trap, as shown in the following table. 

| Interrupt | Exception code | Description                     |
|:---------:|---------------:|:--------------------------------|                 
| 0         | 0              | Instruction address misaligned  |
| 0         | 1              | Instruction access fault        |
| 0         | 2              | Illegal instruction             |
| 0         | 3              | Breakpoint                      |
| 0         | 4              | Load address misaligned         |
| 0         | 5              | Load access fault               |
| 0         | 6              | Store/AMO address misaligned    |
| 0         | 7              | Store/AMO access fault          |
| 0         | 8              | Environment call from U-mode    |
| 0         | 9              | Environment call from S-mode    |
| 0         | 10             | _Reserved_                      |
| 0         | 11             | Environment call from M-mode (`mcause` only)    |
| 0         | 12             | Instruction page fault          |
| 0         | 13             | Load page fault                 |
| 0         | 14             | _Reserved_                      |
| 0         | 15             | Store/AMO page fault            |
| 0         | >= 16          | _Reserved_                      |
| 1         | 0              | _Reserved_                      |
| 1         | 1              | Supervisor software interrupt   |
| 1         | 2              | _Reserved_                      |
| 1         | 3              | Machine software interrupt (`mcause` only)     |
| 1         | 4              | _Reserved_                      |
| 1         | 5              | Supervisor timer interrupt      |
| 1         | 6              | _Reserved_                      |
| 1         | 7              | Machine timer interrupt (`mcause` only)        |
| 1         | 8              | _Reserved_                      |
| 1         | 9              | Supervisor external interrupt   |
| 1         | 10             | _Reserved_                      |
| 1         | 11             | Machine external interrupt (`mcause` only)     |
| 1         | >= 12          | _Reserved_                      |

Besides the `mcause` (or `scause`) register, various additional registers are used to handle traps; when a trap is taken into M-mode (or S-mode), `mepc` (or `sepc`) register is written with the virtual address of the instruction that was interrupted or that encountered the exception. The `mtvec` (or `stvec`) register holds the start address of the trap handler in M-mode (or S-mode). Also, the `mstatus` (or `sstatus`) register keeps track of important information such as M-mode or S-mode interrupt-enable bits (`MIE` or `SIE` bit), the value of the interrupt-enable bit active prior to the trap (`MPIE` or `SPIE` bit), and the previous privilege mode (`MPP` or `SPP` bits). 

To increase performance, certain exceptions and interrupts can be handled at a lower privilege level. For example, setting a bit in `medeleg` or `mideleg` register will delegate the corresponding trap or interrupt, when occurring in S-mode or U-mode, to the S-mode trap handler. By default, `xv6` delegates all interrupts and exceptions to S-mode.

### Handling system calls in `xv6`

Each system call in `xv6` is assigned a unique number, as you can see in `kernel/syscall.h`. This number is used to identify which system call is being requested by a user program. When a user program makes a system call, it places the system call number in a designated register, `a7`, and the arguments for the system call in other registers from `a0` to `a6`. 

The user program then executes a special `ecall` instruction, which triggers a trap from U-mode to S-mode, transferring control to the trap handler `uservec() @ kernel/trampoline.S`. After saving user register contexts and switching into the kernel address space, the RISC-V hart jumps into `usertrap() @ kernel/trap.c`. Note that both system calls and interrupts originating from U-mode are directed to `usertrap()`. If the `sret` (return-from-S-mode) instruction is executed at the end of the system call handler, the control returns to U-mode. 
Additionally, to ensure the program resumes execution at the instruction following the `ecall` instruction, the value of `sepc` should be explicitly incremented by 4 before executing the `sret` instruction. 

The same mechanism can be used for the kernel running in S-mode to request services from M-mode. Specifically, when the kernel executes the `ecall` instruction in S-mode, control is transferred to the M-mode trap handler (unless it is delegated to S-mode). If the hart executes `mret` (return-from-M-mode) instruction in M-mode, control is returned to the location specified by the `mepc` register.

### CLINT (Core-Local INTerruptor)

The RISC-V architecture supports two types of interrupts: local and global. Global interrupts are routed through a Platform-Level Interrupt Controller (PLIC), which can direct interrupts to any hart in the system via the external interrupt. Local interrupts, by contrast, are signaled directly to an individual hart.
Software and timer interrupts are local interrupts generated by the Core-Local Interruptor (CLINT).

CLINT holds memory-mapped control and status registers associated with software and timer interrupts. The following shows the memory map for CLINT.

| Address       | Width   | Attr. | Description            |
|:-------------:|:-------:|:-----:|:-----------------------|  
| `0x0200_0000` | 32 bits | RW    | `msip` for hart 0      |
| `0x0200_0004` | 32 bits | RW    | `msip` for hart 1      |
| `0x0200_0008` | 32 bits | RW    | `msip` for hart 2      |
| `0x0200_000c` | 32 bits | RW    | `msip` for hart 3      |
| `...`         | `...`   | `...` | `...`                  |
| `0x0200_4000` | 64 bits | RW    | `mtimecap` for hart 0  |
| `0x0200_4008` | 64 bits | RW    | `mtimecap` for hart 1  |
| `...`         | `...`   | `...` | `...`                  |
| `0x0200_bff8` | 64 bits | RW    | `mtime` register       |

Machine-mode software interrupts are generated by writing 1 to the memory-mapped control register `msip` in CLINT. Each `msip` register is a 32-bit wide register where the upper 31 bits are tied to 0. The least significant bit is reflected in the `MSIP` bit of the `mip` register. On reset, each `msip` register is cleared to zero. Software interrupts are most useful for interprocessor communication in multi-hart systems, as harts may write each other's `msip` register to effect inter-processor interrupts. 

For more information on CLINT, please refer to Chap. 12 in the [SiFive's Freedom U740 Manual](https://sifive.com/document-file/freedom-u740-c000-manual).


## Problem specification

### 1. Implement the `ping()` system call (60 points)

First, you need to implement the `ping()` system call. The system call number of `ping()` is already assigned to 22 in the `kernel/syscall.h` file. 

__NAME__

`ping` -- send an inter-processor interrupt (IPI) to a RISC-V hart

__SYNOPSYS__
```
    int ping(int h);
```

__DESCRIPTION__

The `ping()` system call sends an IPI to target hart `h`. It can be implemented by entering into M-mode via `ecall` and writing 1 to the `msip` register corresponding to target hart `h`. The target hart then traps into M-mode, provided machine software interrupts are enabled and they are not delegated to S-mode. The target hart's M-mode interrupt handler is responsible for incrementing a per-hart counter in the protected `m_ipi_page` and deasserts the interrupt by writing 0 to its own `msip`.

`ping()` returns after issuing the IPI and does not wait for the target hart to take the software interrupt. Because `msip` is level-triggered and not queued, writing 1 to an `msip` while it is already 1 does not create an additional delivery. To avoid lost IPI requests, it may be necessary to issue a new IPI only after the corresponding `msip` has cleared to 0. Even when `ping()` targets the calling hart itself, it must behave identically to sending it to another hart. We assume that there are no multiple concurrent `ping()` calls to the same hart.

The counters reside in a dedicated 4 KiB memory page (cf. `m_ipi_page` @ `kernel/ipi.c`) that is accessible only in machine mode (M-mode).

__RETURN VALUE__

* On success, `ping()` returns 0.
* On error (e.g., invalid hart ID), `ping()` returns -1.


The following diagram shows the overall flow of the `ping()` system call.
1. A user process on hart 0 invokes `ping(1)`, triggering a system call into the kernel.
2. The S-mode trap handler on hart 0 receives the system call and forwards it to M-mode by issuing another `ecall`.
3. Control transfers to the M-mode trap handler on hart 0.
4. The M-mode trap handler asserts a machine software interrupt to the target by writing 1 to CLINT's `MSIP` register for hart 1.
5. CLINT delivers a machine software interrupt to hart 1.
6. Upon receipt of the machine software interrupt, hart 1's M-mode trap handler increments its counter (`m_ipi_page.hart[1].cnt`).
7. The M-mode handler deasserts the interrupt by writing 0 to its own `msip` register in CLINT.

```
                            ping(1) @ hart 0
U-mode                        |
                              V "ecall"   (1)
---------------------------------------------------------------------------
S-mode                        |
                              V
                       +--------------+
                       | S-mode       |
                       | trap handler |
                       | (hart 0)     |
					   |      |       |
                       |      V       |
					   | sys_ping()   |
                       +--------------+
                              |
                              V "ecall"   (2)
---------------------------------------------------------------------------
M-mode                        |
                              V  (3)
   +---------------+   +--------------+   +--------------+   +--------------+
   | CLINT         |   | M-mode       |   | M-mode       |   | m_ipi_page   |
   |  msip (hart0) |(4)| trap handler |   | trap handler |(6)|  hart[0].cnt |
   |  msip (hart1) |<--| (hart 0)     |   | (hart 1)     |-->|  hart[1].cnt |
   |  ...          |   |              |   |              |   |  ...         |
   +---------------+   +--------------+   +--------------+   +--------------+
         ^   |                                 ^   |
         |   | (5) machine software interrupt  |   |
         |   +---------------------------------+   |
         +-----------------------------------------+
                             (7)
```


### 2. Implement the `pong()` system call (30 points)

You are required to implement the `pong()` system call. The system call number of `pong()` is already assigned to 23 in the `kernel/syscall.h` file. 

__NAME__

`pong` -- read the IPI counter for a RISC-V hart

__SYNOPSYS__
```
    int pong(int h);
```

__DESCRIPTION__

The `pong()` system call returns the number of IPIs that hart `h` has received since the system was booted. The counter is maintained in a protected memory region `m_ipi_page`, which is accessible only in M-mode. Hence, the kernel needs to enter M-mode via `ecall` to read the value. We assume there are no race conditions on the counters, i.e., no counter value is updated while it is being read.


__RETURN VALUE__

* On success, `pong()` returns the current 64-bit counter value for hart `h`.
* On error (e.g., invalid hart ID , `pong()` returns -1.


The overall flow of the `pong()` system call is shown below.
1. A user process on hart 0 invokes `pong(1)`, triggering a system call into the kernel.
2. The S-mode trap handler on hart 0 receives the system call and forwards it to M-mode by issuing another `ecall`.
3. Control transfers to the M-mode trap handler on hart 0.
4. The M-mode handler reads hart 1's counter (`m_ipi_page.hart[1].cnt`) and returns the value all the way to the user process.

```
                            pong(1) @ hart 0
U-mode                        |
                              V "ecall"   (1)
---------------------------------------------------------------------------
S-mode                        |
                              V
                       +--------------+
                       | S-mode trap  |
                       | trap handler |
                       | (hart 0)     |
					   |      |       |
                       |      V       |
					   | sys_pong()   |
                       +--------------+
                              |
                              V "ecall"   (2)
---------------------------------------------------------------------------
M-mode                        |
                              V  (3)
                       +--------------+                      +--------------+
                       | M-mode       |                      | m_ipi_page   |
                       | trap handler |          (4)         |  hart[0].cnt |
                       | (hart 0)     |<-------------------->|  hart[1].cnt |
                       |              |                      |  ...         |
                       +--------------+                      +--------------+
```

### 3. Design Document (10 points)

Prepare a design document detailing your implementation in a single PDF file. Your document should include the following sections.

1. New data structures
   * Provide details about any newly introduced data structures or modifications made to existing ones, including the exact layout of `m_ipi_page`. 
   * Explain why these data structures/modifications were necessary and how they contribute to the implementation.
2. Algorithm design
   * Describe all corner cases you considered and the strategies you used to address them.
   * Discuss any optimizations you applied to improve code efficiency, both in terms of time and space.
3. Testing and validation
   * Outline the test cases you created to validate your implementation, if any.
   * Describe how you verified the correct handling of the corner cases mentioned in Section 2.
   * Explain which part of the project consumed most of your time and why.


## Restrictions

* For this project assignment, you should use the `qemu` version 8.2.0 or higher. To determine the `qemu` version, use the command: `$ qemu-system-riscv64 --version`
* You only need to change the following files in the `./kernel` directory: `ipi.h`, `ipi.c`, `sysproc.c`, and `machinevec.S`. Any other changes will be ignored during grading.


## Tips

* Read Chap. 4.1 of the [xv6 book](http://csl.snu.ac.kr/courses/4190.307/2025-2/book-riscv-rev5.pdf) to understand RISC-V's privileged modes (supervisor mode and machine mode) and trap handling mechanism.
* Read Chap. 4.2 ~ 4.5 of the [xv6 book](http://csl.snu.ac.kr/courses/4190.307/2025-2/book-riscv-rev5.pdf) to see how traps (system calls and interrupts) are handled in xv6.

* For your reference, the following roughly shows the required code changes; each `+` denotes about 1~10 lines to add, remove, or modify.
   ```
   kernel/ipi.c         |  ++
   kernel/ipi.h         |  ++
   kernel/machinevec.S  |  ++++++
   kernel/sysproc.c     |  ++
   ```
  
## Skeleton code

The skeleton code for this project assignment (PA2) is available as a branch named `pa2`. Therefore, you should work on the `pa2` branch as follows:

```
$ git clone https://github.com/snu-csl/xv6-riscv-snu
$ git checkout pa2
```

After downloading, you must first set your `STUDENTID` in the `Makefile` again.

The address of CLINT's `msip` register for hart `hartid` is defined as follows in `memlayout.h`.
```C
#define CLINT               0x2000000L
#define CLINT_MSIP(hartid)  (CLINT + 4*(hartid))
```

Per-hart counters reside in `m_ipi_page`, defined below. You may add additional per-hart fields as needed, as long as the total size does not exceed 4 KiB (4096 bytes). If you do, resize `pad[]` so the overall structure size is exactly 4 KiB.
```C
// @ kernel/ipi.h
struct m_ipi_page_t {
  struct {
    volatile uint64 cnt;
  } hart[NCPU];

  char pad[4096 - sizeof(uint64)*NCPU];
} __attribute__((aligned(4096)));

extern struct m_ipi_page_t m_ipi_page;
``` 

The `pa2` branch has user-level utility programs, `ping` and `pong`, with sources in `user/ping.c` and `user/pong.c`, respectively. The `ping` program invokes the `ping()` system call on a target hart a specified number of times, and the `pong` program invokes the `pong()` system call to report how many IPIs the target hart has received so far. If you have successfully implemented the `ping()` and `pong()` system calls, the output should look like this:


```
qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 4 -nographic -global virtio-mmio.force-legacy=false -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0

xv6 kernel is booting

hart 3 starting
hart 2 starting
hart 1 starting
init: starting sh
$ ping 1
ping: sent 1 IPI to hart 1
$ pong 1
pong: hart 1 count = 1
$ ping 1 100
ping: sent 100 IPIs to hart 1
$ pong 1
pong: hart 1 count = 101
$ 
```

## Hand in instructions

* First, make sure you are on the `pa2` branch in your `xv6-riscv-snu` directory. And then perform the `make submit` command to generate a compressed tar file named `xv6-{PANUM}-{STUDENTID}.tar.gz` in the `../xv6-riscv-snu` directory. Upload this file to the submission server. In addition, you must also upload your design document as a PDF file for this project assignment.

* The total number of submissions for this project assignment will be limited to 30. Only the version marked as `FINAL` will be considered for the project score. Please remember to designate the version you wish to submit using the `FINAL` button. 
  
* Note that the submission server is only accessible inside the SNU campus network. If you want off-campus access (from home, cafe, etc.), you can add your IP address by submitting a Google Form whose URL is available in the eTL. Now, adding your new IP address is automated by a script that periodically checks the Google Form at minutes 0, 20, and 40 during the hours between 09:00 and 00:40 the following day, and at minute 0 every hour between 01:00 and 09:00.
     + If you cannot reach the server a minute after the update time, check your IP address, as you might have sent the wrong IP address.
     + If you still cannot access the server after some time, it is likely due to an error in the automated process. The TAs will verify whether the script is running correctly, but since this check must be performed __manually__, please understand that it may not be completed immediately.

       
## Logistics

* You will work on this project alone.
* Only the upload submitted before the deadline will receive the full credit. 25% of the credit will be deducted for every single day delayed.
* __You can use up to _3 slip days_ during this semester__. If your submission is delayed by one day and you decide to use one slip day, there will be no penalty. In this case, you should explicitly declare the number of slip days you want to use on the QnA board of the submission server before the next project assignment is announced. Once slip days have been used, they cannot be canceled later, so saving them for later projects is highly recommended!
* Any attempt to copy others' work will result in a heavy penalty (for both the copier and the originator). Don't take a risk.

Have fun!

[Jin-Soo Kim](mailto:jinsoo.kim_AT_snu.ac.kr)  
[Systems Software and Architecture Laboratory](http://csl.snu.ac.kr)  
[Dept. of Computer Science and Engineering](http://cse.snu.ac.kr)  
[Seoul National University](http://www.snu.ac.kr)
